#include <stdio.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <fcntl.h>
#include "LineParser.h"

int debug = 0;

void execute(cmdLine *p) {
    if (!p) return;

    if (strcmp(p->arguments[0], "cd") == 0) {
        if (chdir(p->arguments[1]) < 0) perror("cd");
        return;
    }

    if (strcmp(p->arguments[0], "zzzz") == 0) {
        kill(atoi(p->arguments[1]), SIGSTOP);
        return;
    }

    if (strcmp(p->arguments[0], "kuku") == 0) {
        kill(atoi(p->arguments[1]), SIGCONT);
        return;
    }

    if (strcmp(p->arguments[0], "blast") == 0) {
        kill(atoi(p->arguments[1]), SIGINT);
        return;
    }

    pid_t pid = fork();

    if (debug) {
        fprintf(stderr, "PID: %d\n", pid);
        fprintf(stderr, "Executing command: %s\n", p->arguments[0]);
    }

    if (pid == 0) {
        if (p->inputRedirect) {
            int fd = open(p->inputRedirect, O_RDONLY);
            dup2(fd, 0);
            close(fd);
        }
        if (p->outputRedirect) {
            int fd = open(p->outputRedirect, O_WRONLY | O_CREAT | O_TRUNC, 0666);
            dup2(fd, 1);
            close(fd);
        }
        execvp(p->arguments[0], p->arguments);
        perror("execvp");
        _exit(1);
    }

    if (p->blocking) waitpid(pid, 0, 0);
}

int main(int argc, char **argv) {
    if (argc > 1 && strcmp(argv[1], "-d") == 0) debug = 1;

    char cwd[PATH_MAX];
    char buffer[2048];

    while (1) {
        getcwd(cwd, PATH_MAX);
        printf("%s> ", cwd);
        fflush(stdout);

        if (!fgets(buffer, 2048, stdin)) break;

        cmdLine *p = parseCmdLines(buffer);

        if (!p) continue;

        if (strcmp(p->arguments[0], "quit") == 0) {
            freeCmdLines(p);
            break;
        }

        execute(p);
        freeCmdLines(p);
    }

    return 0;
}
